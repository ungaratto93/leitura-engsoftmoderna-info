# Chapter 8 - Testes

## **ExercÃ­cios de FixaÃ§Ã£oÂ [ğŸ”—](https://engsoftmoderna.info/cap8.html#exerc%C3%ADcios-de-fixa%C3%A7%C3%A3o)**

1. (ENADE 2011) Uma equipe estÃ¡ realizando testes com o cÃ³digo-fonte de um sistema. Os testes envolvem a verificaÃ§Ã£o de diversos componentes individualmente, bem como das interfaces entre eles. Essa equipe estÃ¡ realizando testes de:

1. unidade
2. aceitaÃ§Ã£o
3. sistema e aceitaÃ§Ã£o
4. integraÃ§Ã£o e sistema
5. unidade e integraÃ§Ã£o

2. Descreva trÃªs benefÃ­cios associados ao uso de testes de unidade.

3. Suponha uma funÃ§Ã£oÂ `fib(n)`, que retorna o n-Ã©simo termo da sequÃªncia de Fibonacci, isto Ã©,Â `fib(0) = 0`,Â `fib(1) = 1`,Â `fib(2) = 1`,Â `fib(3) = 2`,Â `fib(4) = 3`, etc. Escreva um teste de unidade para essa funÃ§Ã£o.

4. Reescreva o seguinte teste, que verifica o levantamento de uma exceÃ§Ã£oÂ `EmptyStackException`, para que ele fique mais simples e fÃ¡cil de entender.

```
@Test
public void testEmptyStackException() {
  boolean sucesso = false;
  try {
    Stack s<Integer> = new Stack<Integer>();
    s.push(10);
    int r = stack.pop();
    r = stack.pop();
  } catch (EmptyStackException e) {
    sucesso = true;
  }
  assertTrue(sucesso);
}
```

5. Suponha que um programador escreveu o teste a seguir para a classeÂ `ArrayList`Â de Java. Como vocÃª irÃ¡ perceber, no cÃ³digo sÃ£o usados diversosÂ `System.out.println`. Ou seja, no fundo, ele Ã© um teste manual, pois o desenvolvedor tem que conferir o seu resultado manualmente. Reescreva entÃ£o cada um dos testes (de 1 a 6) como um teste de unidade, usando a sintaxe e os comandos do JUnit. ObservaÃ§Ã£o: se quiser executar o cÃ³digo, ele estÃ¡ disponÃ­vel nesteÂ [link](https://gist.github.com/mtov/11d9dce2bd37fe462003992835ebb1ba).

```
import java.util.List;
import java.util.ArrayList;

public class Main {

  public static void main(String[] args) {

    // teste 1
    List<Integer> s = new ArrayList<Integer>();
    System.out.println(s.isEmpty());

    // teste 2
    s = new ArrayList<Integer>();
    s.add(1);
    System.out.println(s.isEmpty());

    // teste 3
    s = new ArrayList<Integer>();
    s.add(1);
    s.add(2);
    s.add(3);
    System.out.println(s.size());
    System.out.println(s.get(0));
    System.out.println(s.get(1));
    System.out.println(s.get(2));

    // teste 4
    s = new ArrayList<Integer>();
    s.add(1);
    s.add(2);
    s.add(3);
    int elem = s.remove(2);
    System.out.println(elem);
    System.out.println(s.get(0));
    System.out.println(s.get(1));

    // teste 5
    s = new ArrayList<Integer>();
    s.add(1);
    s.remove(0);
    System.out.println(s.size());
    System.out.println(s.isEmpty());

    // teste 6
    try {
      s = new ArrayList<Integer>();
      s.add(1);
      s.add(2);
      s.remove(2);
    }

    catch (IndexOutOfBoundsException e) {
      System.out.println("IndexOutOfBound");
    }

  }

}
```

6. Seja a seguinte funÃ§Ã£o. Observe que ela possui quatro comandos, sendo dois delesÂ `if`. Logo, esses doisÂ `ifs`Â geram quatro branches:

```
void f(int x, int y) {
  if (x > 0) {
     x = 2 * x;
     if (y > 0) {
        y = 2 * y;
     }
   }
}
```

Supondo o cÃ³digo acima, preencha a prÃ³xima tabela, com os valores da cobertura de comandos e cobertura de branches obtidos com os testes especificados na primeira coluna (ou seja, a primeira coluna define as chamadas da funÃ§Ã£oÂ `f`Â que o teste realiza).

[Untitled](Chapter%208%20-%20Testes%20dbdc481de2614a35877d17650868f770/Untitled%20Database%2075d01dc1f44f4b01a818bb3798be6b52.csv)

7. Suponha o seguinte requisito: alunos recebem conceito A em uma disciplina se tiverem nota maior ou igual a 90. Seja entÃ£o a seguinte funÃ§Ã£o que implementa esse requisito:

```
boolean isConceitoA(int nota) {
  if (nota > 90)
    return true;
  else return false;
}
```

O cÃ³digo dessa funÃ§Ã£o possui trÃªs comandos, sendo um deles umÂ `if`; logo, ela possui dois branches.

Responda agora Ã s seguintes perguntas.

1. A implementaÃ§Ã£o dessa funÃ§Ã£o possui um bug? Se sim, quando esse bug resulta em falha?
2. Suponha que essa funÃ§Ã£o â€” exatamente como ela estÃ¡ implementada â€” seja testada com duas notas: 85 e 95. Qual a cobertura de comandos desse teste? E a cobertura de branches?
3. Seja a seguinte afirmaÃ§Ã£o: se um programa possui 100% de cobertura de testes, em nÃ­vel de comandos, ele estÃ¡ livre de bugs. Ela Ã© verdadeira ou falsa? Justifique.

8. Complete os comandosÂ `assert`Â nos trechos indicados.

```
public void test1() {
   LinkedList list = mock(LinkedList.class);
   when(list.size()).thenReturn(10);
   assertEquals(___________, ___________);
}

public void test2() {
   LinkedList list = mock(LinkedList.class);
   when(list.get(0)).thenReturn("Engenharia");
   when(list.get(1)).thenReturn("Software");
   String result = list.get(0) + " " + list.get(1);
   assertEquals(___________, ___________);
}
```

9. Suponha duas unidades de cÃ³digo A e B, sendo que A depende de B. Para permitir o teste de unidade de A foi criado um mock para B, chamado B'. O teste de unidade de A estÃ¡ passando. PorÃ©m, ao fazer o teste de integraÃ§Ã£o com A e B, ele falha. Descreva um cenÃ¡rio mais real, no qual A, B, e B' sejam classes reais, com mÃ©todos reais, que realizam funÃ§Ãµes reais, etc. O cenÃ¡rio proposto deve incluir um bug associado ao mock B'. Ou seja, B' esconde um bug, que sÃ³ vai aparecer no teste de integraÃ§Ã£o. Dizendo de outra maneira, B' nÃ£o simula precisamente o comportamento de B; quando B' Ã© removido, no teste de integraÃ§Ã£o, surge entÃ£o um bug.